ข้อ 3. 
    -หลักการทำงานของโปรแกรมที่ทำมาอย่างละเอียด
        เริ่มจากเช็คผลรวมขอทั้งสองคนว่าเกินจำนวนต้นไม้หรือไม่ ถ้าเกินตอบ -1
        ถ้าไม่เกิน ให้คนที่ต้องเลือกเก็บจำนวนต้นมากกว่า เลือกก่อน(กรีดี้อัลกอริทึม)
        ทำการหาผลรวมทุกชุดที่เป็นไปได้ แล้วบันทึกค่าสูงสุดค่าแรกไว้ พร้อมจุดที่เริ่มและจุดสิ้นสุ้นของต้นไม้ที่เก็บ
        ลบต้นไม้ดังกล่าวออกเพื่อไม่ให้ซ้ำ
        ทำการหาผลรวมทุกชุดที่เหลือ บันทึกค่าสูดสุดค่าที่สอง
        นำค่าสูงสุดสองค่ารวมกันได้คำตอบ

    -อธิบาย test case ต่างๆที่ได้คิดเพิ่มไว้ นอกเหนือจากที่โจทย์กำหนด
        97133 2 2
        ครั้งแรกต้องเลือก 97
        ถัดมาต้องเลือก 33
        ผลรวมเป็น 22

    -วิเคราะห์ Complexity ของโปรแกรมตัวเอง เป็น Big O Notation ทั้งในมุม Speed และ Memory Speed 
        N = ขนาด A
        สมมติให้ L>K 
        เก็บชุดแรก วน N รอบ แต่ละรอบวน L ครั้ง =NL
        เก็บชุดที่สอง ข้อมูลเหลือ N-L วน N-L รอบ แต่ละรอบวน K ครั้ง =(N-L)K
        รวมได้ NL+(N-L)K = O(n^2)

        memory ใช้เก็บข้อมูล N ช่องตามขนาดอินพุต และ เก็บ max1 max2 indexstart/stop 
        (N+4)*8 bytes


ข้อ 4
    -หลักการทำงานของโปรแกรมที่ทำมาอย่างละเอียด
        1. วนรับค่า
        2. พิจารณาตำแหน่งปัจจุบันว่า มีค่า 0 อยู่หรือไม่ ถ้าหากมี จะสามารถตรวจสอบได้ภายใน 0(1) ว่ามีเลเซอตัดผ่านหรือยัง
        3. จาก (2) หาก ไม่มีค่า 0 จะทำการหาค่า gcd ของพิกัด เพื่อนำมาหาค่าเศษส่วนอย่างต่ำ ซึ่งค่าดังกล่าวจะนำมาใช้ในการอ้างอิงว่ามีเลเซอร์ยิงผ่านจุดที่เสาตั้งอยู่หรือยัง
            (ซึ่งการยิงของเลเซอร์จะเป็นสมการเส้นตรง)
        

        
    -อธิบาย test case ต่างๆที่ได้คิดเพิ่มไว้ นอกเหนือจากที่โจทย์กำหนด
        1. กรณีที่ค่า x หรือ y เป็น 0 อย่างใดอย่างหนึ่ง และ (x, y) จะต้องไม่เท่ากับ (0, 0)
        
    -อธิบายหลักการแก้ปัญหาโจทย์ ว่าใช้เทคนิค หรือ Algorithm แบบไหนในการแก้
        1. ใช้ Euclidean Algorithm ในการหาค่าร่วมมาก เพื่อหาเศษส่วนอย่างต่ำ 

    -วิเคราะห์ Complexity ของโปรแกรมตัวเอง เป็น Big O Notation ทั้งในมุม Speed และ Memory
        Speed 
            วนค่าตามจำนวนสมาชิก = o(N)
            Euclidean Algorithm = o(logN)
            ตรวจสอบค่าเศษส่วนอย่างต่ำในแต่ละครั้ง = o(M)
            รวมทั้งหมด (MNlogN) 
        Memory * ไม่รวมข้อมูล input
            
            หน่วยความจำที่ใช้สูงสุด กรณีค่าไม่ซ้ำกันเลย 
            (จำนวนชุดข้อมูลสูงสุด * 2(ชุดข้อมูล x และ y) * long int c type memory *  )
            100 000 * 2 * 8 = 1600000 bytes
ข้อ 5. 
    -หลักการทำงานของโปรแกรมที่ทำมาอย่างละเอียด
        เป็นการเลือกของ r สิ่งจาก n สิ่ง โดยการจัดหมู่ แล้วคำนวนผลรวมของข้อมูลแต่ละชุด
        ลูปแรกใช้เป็นจุดเริ่มต้น
        ลูปถัดมาใช้วนจากจุดเริ่มต้นไปจุดสุดท้าย เพื่อหาว่าได้ผลรวม S หรือไม่
        หากได้ผลรวมเท่ากับ S ก็จะหาความกว้างช่วงโดยใช้จุดปัจจุบันลบจุดเริ่มต้น 
        หากความกว้างช่วงที่หาได้มีค่ามากกว่าความกว้างเดิม ก็อัพเดทความกว้างนั้น
        เมื่อเสร็จโปรแกรมจะได้ช่วงความกว้างที่มากที่สุดที่ผลรวมเท่ากับ S
      

    -อธิบาย test case ต่างๆที่ได้คิดเพิ่มไว้ นอกเหนือจากที่โจทย์กำหนด
        00001-1 0
        ต้องตอบ 6 เนื่องจากเป็นช่วงที่ยาวที่สุด

    -วิเคราะห์ Complexity ของโปรแกรมตัวเอง เป็น Big O Notation ทั้งในมุม Speed และ Memory Speed 
        N = ขนาด A
        วน N รอบ แต่ละรอบวน N-1 ครั้ง
        รวมได้ N(N-1) = O(n^2)

        memory ใช้เก็บข้อมูล N ช่องตามขนาดอินพุต และ เก็บ max sum indexstart
        (N+3)*8 bytes
